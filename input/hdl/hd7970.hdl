/*
 * Copyright 2014 Pieter Hijma
 *
 * This file is part of MCL.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

hardware_description hd7970 

specializes amd;

parallelism hierarchy {
    memory_space global {
		consistency = barrier;
		default;
    }

    memory_space constant {
		consistency = full;
		read_only;
    }

    par_group workgroups {
		max_nr_units = 65000;
	
		par_unit workgroup {
	
		    memory_space local {
				consistency = barrier;
		    }
	
		    par_group wavefronts {
				max_nr_units = 4;
		
				par_unit wavefront {
		
				    par_group workitems {
						nr_units = 64;
		
						par_unit workitem {
						    memory_space reg {
								consistency = full;
								default;
						    }
						    memory_space private {
								consistency = full;
						    }
						}
				    }
				}
		    }
		}
    }
}

device host {
}

interconnect pcie {
    connects(host, hd7970.device_mem);
    latency = 1000 cycles;
    bandwidth = 8 GB/s;
}

device hd7970 {
    device_mem;
    ic1;
    constant_cache;
    l2_cache;
    ic2;
    cus;
}

memory device_mem {
    space(global);
    space(private);
    space(constant);
    capacity = 3 GB;
}

interconnect ic1 {
    connects(device_mem, constant_cache);
    connects(device_mem, l2_cache);
    latency = 800 cycles;
    clock_frequency = 1375 MHz;
    width = 384 bits;
}

cache constant_cache {
    space(constant);
    capacity = 128 kB;
}

cache l2_cache {
	space(global);
	space(private);
	capacity = 768 kB;
	cache_line_size = 64 B;
}

interconnect ic2 {
    connects(constant_cache, cus.cu[*]);
    connects(l2_cache, cus.cu[*]);
    latency = 20 cycles;
    bandwidth = 100 GB/s;
}

execution_group cus {
    nr_units = 32;

    execution_unit cu {
		slots(workgroup, 16);
		slots(wavefront, 40);
	
		on_chip;
		l1_cache;
		regs;
		alus;
		load_store_units;
    }
}

memory on_chip {
    space(local);
    capacity = 64 kB;
    nr_banks = 32;
}

cache l1_cache {
	space(global);
	space(private);
	capacity = 16 kB;
	cache_line_size = 64B;
}

memory regs {
    space(reg);
    addressable = false;
    capacity = 65536 * 32 bit;
}

// actually, it has 4 vector units of 32 units each
simd_group alus {
    nr_units = 64;

    slots(wavefront, 1);

    simd_unit alu {
		slots(workitem, 1);
	
		instructions ops {
			op((+), 1);
		}
    }
}


load_store_group load_store_units {
    nr_units = 64;

    slots(wavefront, 1);
    
    performance_feedback("load_store_optimality");

    connects(regs, l1_cache);
    connects(regs, constant_cache);
    connects(regs, on_chip);

    load_store_unit ls_unit {
		slots(workitem, 1);
	
		instructions ls_ops {
		    op("load", 1);
		    op("store", 1);
		}
    }
}
