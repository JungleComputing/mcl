/*
 * Copyright 2014 Pieter Hijma
 *
 * This file is part of MCL.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */



module convolution

import perfect;

perfect void convolve(int outputHeight, int outputWidth, 
		int filterHeight, int filterWidth, 
		float [outputHeight, outputWidth] output, 
		float [outputHeight + filterHeight/2*2, 
			outputWidth + filterWidth/2*2] input, 
		float [filterHeight, filterWidth] filter) {
	foreach (int i in outputHeight threads) {
		foreach(int j in outputWidth threads) {
			float sum = 0.0;
			for (int y = 0; y < filterHeight; y++) {
				for (int x = 0; x < filterWidth; x++) {
					sum = sum + filter[y, x] * input[i + y, j + x];
				}
			}
			output[i, j] = sum / (filterHeight * filterWidth);
		}
	}
}
/*

INFO at |project://mcl/input/programs/convolution.mcl|(519,6,<16,17>,<16,23>): Data reuse: filter[y,x] is accessed for outputWidth threads j.
INFO at |project://mcl/input/programs/convolution.mcl|(519,6,<16,17>,<16,23>): Data reuse: filter[y,x] is accessed for outputHeight threads i.
INFO at |project://mcl/input/programs/convolution.mcl|(534,5,<16,32>,<16,37>): Data reuse: For input[i + y,j + x]:
  For dimension 0:
    the loops const int i, int y = 0 may have a positive data reuse ratio: filterHeight * outputHeight / (filterHeight + (outputHeight - 1))
  For dimension 1:
    the loops const int j, int x = 0 may have a positive data reuse ratio: filterWidth * outputWidth / (filterWidth + (outputWidth - 1))
INFO at |project://mcl/input/programs/convolution.mcl|(50,8,<5,13>,<5,21>): Arithmetic intensity: (2*filterHeight*filterWidth*outputHeight*outputWidth+2*outputHeight*outputWidth)*(
2*filterHeight*filterWidth*outputHeight*outputWidth+outputHeight*outputWidth)^(
-1)
INFO at |project://mcl/input/programs/convolution.mcl|(50,8,<5,13>,<5,21>): control flow:
  threads:
    instructions: 
      2*filterHeight*filterWidth*outputHeight*outputWidth+2*filterHeight*outputHeight*outputWidth
INFO at |project://mcl/input/programs/convolution.mcl|(50,8,<5,13>,<5,21>): indexing:
  threads:
    instructions: 
      2*filterHeight*filterWidth*outputHeight*outputWidth
INFO at |project://mcl/input/programs/convolution.mcl|(50,8,<5,13>,<5,21>): computation:
  threads:
    loads: 
      main: 2*filterHeight*filterWidth*outputHeight*outputWidth
    instructions: 
      2*filterHeight*filterWidth*outputHeight*outputWidth+2*outputHeight*outputWidth
    stores: 
      main: outputHeight*outputWidth

openCL.run(NDRange(128, 131072), NDRange(32, 32)
convolveKernel           : avg = 21.2 ms, total = 21.2 ms, count =         1


GPU

#GFLOPS: 129.96 GFLOPS
Effective Bandwidth: 481.2 GB/s
Bandwidth: 5.9173 GB/s



Xeon Phi

convolveKernel           : avg = 41.5 ms, total =  207 ms, count =         5

#GFLOPS: 66.357 GFLOPS
Effective Bandwidth: 245.69 GB/s
Bandwidth: 3.0212 GB/s



*/
