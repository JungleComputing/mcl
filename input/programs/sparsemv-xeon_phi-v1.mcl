/*
 * Copyright 2014 Pieter Hijma
 *
 * This file is part of MCL.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */



module sparsemv


import perfect;
import mic;
import xeon_phi;


// Try to get good cache behaviour vor avalues and ajc.


xeon_phi void sparsemv(const int n, const int m, const int nz, const int[n + 1] 
        air, const int[nz] ajc, const float[nz] avalues, const float[m] b, 
        float[n] c) {
    const int nrVectorsN = mic.hierarchy.threads.thread.vectors.nr_units;
    const int nrThreadsN = n / (1 * nrVectorsN);
	dev float [n, nrVectorsN] dsums;
    foreach (const int tarow in nrThreadsN threads) {
        foreach (const int varow in nrVectorsN vectors) {
        	// float[nrVectorsN] sums;
        	float sum;
         	for (int ei = 0; ei < nrVectorsN; ei++) {
	            const int arow = tarow * nrVectorsN + ei;
	            const int start = air[arow] + varow;
	            const int end = air[arow + 1];
	            sum = 0;
	            // This should give good cache behaviour for avalues and ajc.
	            for (int i = start; i < end; i += nrVectorsN) {
	                sum = sum + avalues[i] * b[ajc[i]];
	            }
	            // sums[ei] = sum;
	            dsums[arow, varow] = sum;	// This is expensive, in fact about 85% of this
	            							// loop, unfortunately.
	        }

//	        barrier(dev);

	        sum = 0;
	        // This phase takes less than 10% of the total run, although access
	        // to the dsums array is not coalesced.
	        const int r = tarow * nrVectorsN + varow;
	        for (int ei = 0; ei < nrVectorsN; ei++) {
	        	sum = sum + dsums[r, ei];
	        }
	        c[r] = sum;


	        /*
	        // Make each varow update a different entry of c.
	        int ind = varow;
	        for (int ei = 0; ei < nrVectorsN; ei++) {
	           	const int arow = tarow * nrVectorsN + ind;
	           	c[arow] = c[arow] + sums[ind];
	           	ind = ind + 1;
	           	if (ind > 15) {
	           		ind = 0;
	           	}
	           	// barrier(dev);
	        }
	        */
        }
    }
}

/*
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(137,8,<12,14>,<12,22>): This is a cache-oriented architecture. Make sure that each access benefits from the cache(s)
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(1099,5,<32,13>,<32,18>): Var dsums[arow,varow]:
  in loop ei:
    does not benefit from cache l1_cache:
      16 cache line fetches
  in foreach loop varow:
    does benefit from cache l1_cache:
      1 cache line fetches
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(1523,5,<43,22>,<43,27>): Var dsums[r,ei]:
  in loop ei:
    may benefit from cache l1_cache:
      best case: 1 cache line fetches
      worst case: 16 cache line fetches
  in foreach loop varow:
    does not benefit from cache l1_cache:
      16 cache line fetches
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(1557,1,<45,9>,<45,10>): Var c[r]:
  in foreach loop varow:
    does benefit from cache l1_cache:
      1 cache line fetches
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(1028,1,<29,42>,<29,43>): Var b[ajc[i]]:: unpredictable access pattern
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(1015,7,<29,29>,<29,36>): Var avalues[i]:
  in loop i:
    does not benefit from cache l1_cache:
      end / 16 + (air[arow] + varow) / -16 cache line fetches
 (may not be accurate: depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(482,5,<18,23>,<18,28>), depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(646,2,<22,19>,<22,21>), depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(540,5,<19,27>,<19,32>))
  in foreach loop varow:
    the array index depends on the loop index, but not directly. Cache behaviour cannot be predicted.
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(1030,3,<29,44>,<29,47>): Var ajc[i]:
  in loop i:
    does not benefit from cache l1_cache:
      end / 16 + (air[arow] + varow) / -16 cache line fetches
 (may not be accurate: depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(482,5,<18,23>,<18,28>), depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(646,2,<22,19>,<22,21>), depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(540,5,<19,27>,<19,32>))
  in foreach loop varow:
    the array index depends on the loop index, but not directly. Cache behaviour cannot be predicted.
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(813,3,<25,29>,<25,32>): Var air[arow + 1]:
  in loop ei:
    may benefit from cache l1_cache:
      best case: 1 cache line fetches
      worst case: 16 cache line fetches
  in foreach loop varow:
    does benefit from cache l1_cache:
      1 cache line fetch
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(765,3,<24,31>,<24,34>): Var air[arow]:
  in loop ei:
    may benefit from cache l1_cache:
      best case: 1 cache line fetches
      worst case: 16 cache line fetches
  in foreach loop varow:
    does benefit from cache l1_cache:
      1 cache line fetch
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(1099,5,<32,13>,<32,18>): Var dsums[arow,varow]:
  in loop ei:
    does not benefit from cache l2_cache:
      16 cache line fetches
  in foreach loop varow:
    does benefit from cache l2_cache:
      1 cache line fetches
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(1523,5,<43,22>,<43,27>): Var dsums[r,ei]:
  in loop ei:
    may benefit from cache l2_cache:
      best case: 1 cache line fetches
      worst case: 16 cache line fetches
  in foreach loop varow:
    does not benefit from cache l2_cache:
      16 cache line fetches
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(1557,1,<45,9>,<45,10>): Var c[r]:
  in foreach loop varow:
    does benefit from cache l2_cache:
      1 cache line fetches
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(1028,1,<29,42>,<29,43>): Var b[ajc[i]]:: unpredictable access pattern
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(1015,7,<29,29>,<29,36>): Var avalues[i]:
  in loop i:
    does not benefit from cache l2_cache:
      end / 16 + (air[arow] + varow) / -16 cache line fetches
 (may not be accurate: depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(482,5,<18,23>,<18,28>), depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(646,2,<22,19>,<22,21>), depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(540,5,<19,27>,<19,32>))
  in foreach loop varow:
    the array index depends on the loop index, but not directly. Cache behaviour cannot be predicted.
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(1030,3,<29,44>,<29,47>): Var ajc[i]:
  in loop i:
    does not benefit from cache l2_cache:
      end / 16 + (air[arow] + varow) / -16 cache line fetches
 (may not be accurate: depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(482,5,<18,23>,<18,28>), depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(646,2,<22,19>,<22,21>), depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(540,5,<19,27>,<19,32>))
  in foreach loop varow:
    the array index depends on the loop index, but not directly. Cache behaviour cannot be predicted.
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(813,3,<25,29>,<25,32>): Var air[arow + 1]:
  in loop ei:
    may benefit from cache l2_cache:
      best case: 1 cache line fetches
      worst case: 16 cache line fetches
  in foreach loop varow:
    does benefit from cache l2_cache:
      1 cache line fetch
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(765,3,<24,31>,<24,34>): Var air[arow]:
  in loop ei:
    may benefit from cache l2_cache:
      best case: 1 cache line fetches
      worst case: 16 cache line fetches
  in foreach loop varow:
    does benefit from cache l2_cache:
      1 cache line fetch
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(137,8,<12,14>,<12,22>): pcie transfers 4 * m + (4 * n + 8 * nz) + 16 bytes from host to device
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(137,8,<12,14>,<12,22>): pcie transfers 4 * n bytes from device to host
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(1030,3,<29,44>,<29,47>): Data reuse: For ajc[i]:
    the loops const int varow, int ei = 0  have a positive data reuse ratio: 256
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(1028,1,<29,42>,<29,43>): Data reuse: For b[ajc[i]]:
    the loops const int varow, int ei = 0 may have a positive data reuse ratio: 256 / (ajc[((i))] + 1)
    the loops const int tarow, int ei = 0 may have a positive data reuse ratio: n / (ajc[((i))] + 1)
    the loops int ei = 0, int i = start may have a positive data reuse ratio: (-1 * air[((arow))] + (end + -1 * varow)) / (ajc[((i))] + 1)
    the loops const int varow, int i = start may have a positive data reuse ratio: (-1 * air[((arow))] + (end + -1 * varow)) / (ajc[((i))] + 1)
    the loops const int tarow, const int varow may have a positive data reuse ratio: n / (ajc[((i))] + 1)
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(1015,7,<29,29>,<29,36>): Data reuse: For avalues[i]:
    the loops const int varow, int ei = 0  have a positive data reuse ratio: 256
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(813,3,<25,29>,<25,32>): Data reuse: air[arow + 1] is accessed for nrVectorsN vectors varow.
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(765,3,<24,31>,<24,34>): Data reuse: air[arow] is accessed for nrVectorsN vectors varow.
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(137,8,<12,14>,<12,22>): computation:
  vectors:
    loads: 
      dev: nrThreadsN*nrVectorsN^2+2*nrThreadsN*nrVectorsN*(-start+end) (may not be accurate: depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(482,5,<18,23>,<18,28>), depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(646,2,<22,19>,<22,21>), depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(540,5,<19,27>,<19,32>))
    instructions: 
      nrThreadsN*nrVectorsN^2+2*nrThreadsN*nrVectorsN*(-start+end) (may not be accurate: depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(482,5,<18,23>,<18,28>), depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(646,2,<22,19>,<22,21>), depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(540,5,<19,27>,<19,32>))
    stores: 
      dev: nrThreadsN*nrVectorsN^2+nrThreadsN*nrVectorsN (may not be accurate: depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(482,5,<18,23>,<18,28>), depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(646,2,<22,19>,<22,21>), depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(540,5,<19,27>,<19,32>))
ok

INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(137,8,<12,14>,<12,22>): indexing:
  vectors:
    loads: 
      dev: nrThreadsN*nrVectorsN*(-start+end) (may not be accurate: depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(482,5,<18,23>,<18,28>), depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(646,2,<22,19>,<22,21>), depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(540,5,<19,27>,<19,32>))
    instructions: 
      nrThreadsN*nrVectorsN^2+2*nrThreadsN*nrVectorsN (may not be accurate: depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(482,5,<18,23>,<18,28>), depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(646,2,<22,19>,<22,21>), depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(540,5,<19,27>,<19,32>))
    stores: 
      dev: 0 (may not be accurate: depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(482,5,<18,23>,<18,28>), depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(646,2,<22,19>,<22,21>), depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(540,5,<19,27>,<19,32>))
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(137,8,<12,14>,<12,22>): control flow:
  host:
    instructions: 
      2
  vectors:
    loads: 
      dev: 2*nrThreadsN*nrVectorsN^2
    instructions: 
      7*nrThreadsN*nrVectorsN^2+2*nrThreadsN*nrVectorsN*(-start+end) (may not be accurate: depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(482,5,<18,23>,<18,28>), depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(646,2,<22,19>,<22,21>), depends on loop at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(540,5,<19,27>,<19,32>))
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(137,8,<12,14>,<12,22>): Arithmetic intensity: (nrThreadsN*nrVectorsN^2+2*nrThreadsN*nrVectorsN*(-start+end))*(2*nrThreadsN*nrVectorsN^
2+2*nrThreadsN*nrVectorsN*(-start+end)+nrThreadsN*nrVectorsN)^(-1)
INFO at |project://mcl/input/programs/sparsemv-xeon_phi-v1.mcl|(297,1,<14,17>,<14,18>): It may be beneficial to consider computing more than one element of c per vector.


openCL.run(NDRange(65536), NDRange(16)
pre                      : avg = 5.91 ms, total = 17.7 ms, count =         3

sparsemvKernel           : avg = 5.97 ms, total = 5.97 ms, count =         1

sparsemvKernel           : avg = 5.96 ms, total = 11.9 ms, count =         2

sparsemvKernel           : avg = 5.96 ms, total = 17.9 ms, count =         3

sparsemvKernel           : avg = 5.97 ms, total = 23.9 ms, count =         4

sparsemvKernel           : avg = 5.93 ms, total = 29.6 ms, count =         5

Bandwidth: 11.622 GB/s
*/