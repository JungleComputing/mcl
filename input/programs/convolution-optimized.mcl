/*
 * Copyright 2014 Pieter Hijma
 *
 * This file is part of MCL.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */



module convolution


import gpu;





gpu void convolve(const int outputHeight, const int outputWidth, const int 
        filterHeight, const int filterWidth, float[outputHeight,outputWidth] 
        output, const float[outputHeight + filterHeight / 2 * 2,outputWidth + 
        filterWidth / 2 * 2] input, const float[filterHeight,filterWidth] 
        filter) {

	const int tyleHeight = 1;
	const int tyleWidth = 8;
	const int nrThreadsX = 32;
	const int nrThreadsY = 8;
	const int nrBlocksOutputHeight = outputHeight / (nrThreadsY * tyleHeight);
    const int nrBlocksOutputWidth = outputWidth / (nrThreadsX * tyleWidth);
    const int filterSize = filterWidth * filterHeight;
    const int fh = filterHeight / 2 * 2;
    const int fw = filterWidth / 2 * 2;
    const int ti_end = fh + nrThreadsY * tyleHeight;
	const int tj_end = fw + nrThreadsX * tyleWidth;
	const int nrThreads = nrThreadsX * nrThreadsY;
     
    foreach (const int bi in nrBlocksOutputHeight blocks) {   
        foreach (const int bj in nrBlocksOutputWidth blocks) {
        
        	local float [filterHeight, filterWidth] f;
        	f as float[filterSize] f2;
        	filter as float[filterSize] filter2;
        	local float [ti_end, tj_end] data;
        	
        	foreach(const int ti in nrThreadsY threads) {
        		foreach(const int tj in nrThreadsX threads) {
         			const int yDataOffset = bi * (nrThreadsY * tyleHeight);
        			const int xDataOffset = bj * (nrThreadsX * tyleWidth); 
					const int j = xDataOffset + tj;
					const int i = yDataOffset + ti;
	                float sum0 = 0.0;
	                float sum1 = 0.0;
	                float sum2 = 0.0;
	                float sum3 = 0.0;
	                float sum4 = 0.0;
	                float sum5 = 0.0;
	                float sum6 = 0.0;
	                float sum7 = 0.0;
	
	            	for (int k = ti * nrThreadsX + tj; k < filterSize; k += nrThreads) {
	            		f2[k] = filter2[k];
	            	}
	            	for (int mti = ti; mti < ti_end; mti += nrThreadsY) {
	            		for (int mtj = tj; mtj < tj_end; mtj += nrThreadsX) {
	            			data[mti, mtj] = input[yDataOffset + mti, xDataOffset + mtj];
	            		}
	            	}
            	
	            	barrier(local);
	        
	                for (int y = 0; y < filterHeight; y++) {	                
	                    for (int x = 0; x < filterWidth; x++) {	                    
	                        sum0 = sum0 + f[y, x] * data[ti*tyleHeight + y,tj + x + 0 * nrThreadsX];
	                        sum1 = sum1 + f[y, x] * data[ti*tyleHeight + y,tj + x + 1 * nrThreadsX];
	                        sum2 = sum2 + f[y, x] * data[ti*tyleHeight + y,tj + x + 2 * nrThreadsX];
	                        sum3 = sum3 + f[y, x] * data[ti*tyleHeight + y,tj + x + 3 * nrThreadsX];
	                        sum4 = sum4 + f[y, x] * data[ti*tyleHeight + y,tj + x + 4 * nrThreadsX];
	                        sum5 = sum5 + f[y, x] * data[ti*tyleHeight + y,tj + x + 5 * nrThreadsX];
	                        sum6 = sum6 + f[y, x] * data[ti*tyleHeight + y,tj + x + 6 * nrThreadsX];
	                        sum7 = sum7 + f[y, x] * data[ti*tyleHeight + y,tj + x + 7 * nrThreadsX];
	                    }
	                }
	                output[i,j + 0 * nrThreadsX] = sum0 / filterSize;
	                output[i,j + 1 * nrThreadsX] = sum1 / filterSize;
	                output[i,j + 2 * nrThreadsX] = sum2 / filterSize;
	                output[i,j + 3 * nrThreadsX] = sum3 / filterSize;
	                output[i,j + 4 * nrThreadsX] = sum4 / filterSize;
	                output[i,j + 5 * nrThreadsX] = sum5 / filterSize;
	                output[i,j + 6 * nrThreadsX] = sum6 / filterSize;
	                output[i,j + 7 * nrThreadsX] = sum7 / filterSize;
	            }
	        }
        }
    }
}
