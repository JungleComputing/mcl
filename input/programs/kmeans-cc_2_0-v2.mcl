/*
 * Copyright 2014 Pieter Hijma
 *
 * This file is part of MCL.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

module kmeans




import perfect;
import gpu;
import nvidia;
import cc_2_0;








// cluster-swapping to shared memory, reduced nPointsPerThreaad.

cc_2_0 void kmeans_kernel(const int npoints, const int nclusters, const int 
	nfeatures, const global float[nfeatures,npoints] points, const global 
	float[nclusters,nfeatures] clusters, global int[npoints] 
	pointsCluster) {
    const int nPointsPerThread = 1;
    const int nrThreadsNpoints = gpu.hierarchy.blocks.block.threads.
	max_nr_units;
    const int nrBlocksNpoints = (npoints + nrThreadsNpoints * nPointsPerThread 
	    - 1) / (1 * nrThreadsNpoints * nPointsPerThread);
    const int clusterBlockSize = 2048/nfeatures;
    const int nClusterBlocks = (nclusters + clusterBlockSize - 1) / clusterBlockSize;
    clusters as float[nclusters*nfeatures] clusters2;

    foreach (const int bpid in nrBlocksNpoints blocks) {
	const int nrThreadsNrThreadsNpoints = cc_2_0.hierarchy.blocks.block.
	    warps.warp.threads.nr_units;
	const int nrWarpsNrThreadsNpoints = nrThreadsNpoints / (1 * 
		nrThreadsNrThreadsNpoints);
		
	shared float[clusterBlockSize, nfeatures] clusterBlock;
	clusterBlock as float[clusterBlockSize * nfeatures] clusterBlock2;
	
	foreach (const int wtpid in nrWarpsNrThreadsNpoints warps) {
	    foreach (const int ttpid in nrThreadsNrThreadsNpoints threads) {
		const int tpid = wtpid * (1 * nrThreadsNrThreadsNpoints * nPointsPerThread) + 
		    ttpid;

		int[nPointsPerThread] ind;
		float[nPointsPerThread] min_dist;

		for (int i = 0; i < nPointsPerThread; i++) {
		    ind[i] = 0;
		    min_dist[i] = 3.0E+38;
		}

		for (int clusterIter = 0; clusterIter < nClusterBlocks; clusterIter++) {
		    // Initialize clusterBlock
		    int cbsz = clusterBlockSize;
		    int cboffset = clusterIter * clusterBlockSize;
		    if (nclusters < cboffset + clusterBlockSize) {
			cbsz = nclusters - cboffset;
		    }

		    for (int i = wtpid * nrThreadsNrThreadsNpoints + ttpid; i < cbsz * nfeatures; i += nrThreadsNrThreadsNpoints * nrWarpsNrThreadsNpoints) {
			clusterBlock2[i] = clusters2[i + nfeatures * cboffset];
		    }

		    barrier(shared);

		    for (local int p = 0; p < nPointsPerThread; p++) {
			const int pid = bpid * (1 * nrThreadsNpoints * 
				nPointsPerThread) + p * nrThreadsNrThreadsNpoints + tpid;
			if (pid < npoints) {
			    float[nfeatures] point;
			    for(local int feature = 0; feature < nfeatures; 
				    feature++) {
				point[feature] = points[feature, pid];
			    }

			    for (local int cluster = 0; cluster < cbsz; cluster++) {
				local float dist = 0;
				for (local int feature = 0; feature < nfeatures; 
					feature++) {
				    const float d = point[feature] - clusterBlock[cluster,feature];
				    dist = dist + d * d;
				}
				if (dist < min_dist[p]) {
				    min_dist[p] = dist;
				    ind[p] = cluster + clusterIter * clusterBlockSize;
				}
			    }
			}
		    }
		    barrier(shared);
		}
		for (local int p = 0; p < nPointsPerThread; p++) {
		    const int pid = bpid * (1 * nrThreadsNpoints * 
			nPointsPerThread) + p * nrThreadsNrThreadsNpoints + tpid;
		    if (pid < npoints) {
			pointsCluster[pid] = ind[p];
		    }
		}
	    }
	}
    }
}
/*


 */
