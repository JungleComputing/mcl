/*
 * Copyright 2014 Pieter Hijma
 *
 * This file is part of MCL.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */



module convolution


import cc_1_0;





cc_1_0 void convolve(const int outputHeight = 4096, const int outputWidth = 
        4096, const int filterHeight = 9, const int filterWidth = 9, 
        float[outputHeight,outputWidth] output, const float[outputHeight + 
        filterHeight / 2 * 2,outputWidth + filterWidth / 2 * 2] input, const 
        float[filterHeight,filterWidth] filter) {

    const int tyleHeight = 8;
    const int tyleWidth = 1;
    const int nrThreadsX = 64;
    const int nrThreadsY = 4;
    const int nrBlocksOutputHeight = outputHeight / (nrThreadsY * tyleHeight);
    const int nrBlocksOutputWidth = outputWidth / (nrThreadsX * tyleWidth);
    const int filterSize = filterWidth * filterHeight;
    const int fh = filterHeight / 2 * 2;
    const int fw = filterWidth / 2 * 2;
    const int ti_end = fh + nrThreadsY * tyleHeight;
    const int tj_end = fw + nrThreadsX * tyleWidth;
    foreach (const int bi in nrBlocksOutputHeight blocks) {
    
        foreach (const int bj in nrBlocksOutputWidth blocks) {
        
            shared float[filterHeight,filterWidth] f;
            f as float[filterSize] f2;
            filter as float[filterSize] filter2;
            shared float[ti_end,tj_end] data;
            const int nrThreadsNrThreadsX = 
                    cc_1_0.hierarchy.blocks.block.warps.warp.threads.nr_units;
            const int nrWarpsNrThreadsX = nrThreadsX / nrThreadsNrThreadsX;
            foreach (const int ti in nrThreadsY warps) {
            
                foreach (const int wtj in nrWarpsNrThreadsX warps) {
                
                    foreach (const int ttj in nrThreadsNrThreadsX threads) {
                    
                        const int tj = wtj * nrThreadsNrThreadsX + ttj;
                        const int yDataOffset = bi * (nrThreadsY * tyleHeight);
                        const int xDataOffset = bj * (nrThreadsX * tyleWidth);
                        const int j = xDataOffset + tj * tyleWidth;
                        const int i = yDataOffset + ti * tyleHeight;
                        local float[tyleHeight] sum;
                        for (local int k = ti * nrThreadsX + tj; k < 
                                filterSize; k += nrThreadsX * nrThreadsY) {
                        
                            f2[k] = filter2[k];
                        }
                        for (local int mti = ti; mti < ti_end; mti += 
                                nrThreadsY) {
                        
                            for (local int mtj = tj; mtj < tj_end; mtj += 
                                    nrThreadsX) {
                            
                                data[mti,mtj] = input[yDataOffset + mti,
                                        xDataOffset + mtj];
                            }
                        }
                        barrier(shared);
                        for (local int k = 0; k < tyleHeight; k++) {
                        
                            sum[k] = 0;
                        }
                        for (local int y = 0; y < filterHeight; y++) {
                        
                            for (local int x = 0; x < filterWidth; x++) {
                            
                                for (local int k = 0; k < tyleHeight; k++) {
                                
                                    sum[k] = sum[k] + f[y,x] * data[ti * 
                                            tyleHeight + y + k,tj + x];
                                }
                            }
                        }
                        for (local int k = 0; k < tyleHeight; k++) {
                        
                            output[i + k,j] = sum[k] / filterSize;
                        }
                    }
                }
            }
        }
    }
}
/*
INFO at |project://mcl/input/programs/convolution-cc_1_0.mcl|(1097,1,<31,51>,<31,52>): Multiple elements of f2 are loaded into shared memory, but there is only one store/load phase. It may be benificial to store/load in multiple phases.
INFO at |project://mcl/input/programs/convolution-cc_1_0.mcl|(2316,7,<53,36>,<53,43>): Memory access pattern of filter2[k] is optimal
INFO at |project://mcl/input/programs/convolution-cc_1_0.mcl|(2698,5,<61,48>,<61,53>): Memory access pattern of input[yDataOffset + mti,xDataOffset + mtj] is optimal
INFO at |project://mcl/input/programs/convolution-cc_1_0.mcl|(3707,6,<83,28>,<83,34>): Memory access pattern of output[i + k,j] is optimal
INFO at |project://mcl/input/programs/convolution-cc_1_0.mcl|(3412,4,<76,63>,<76,67>): For data[ti * tyleHeight + y + k,tj + x]:
  For dimension 0:
    the loops local int y = 0, local int k = 0 have a positive data reuse ratio: a factor 4.5
      memory space local may be leveraged
    the loops const int ti, local int y = 0 have a positive data reuse ratio: a factor 1.090909091
  For dimension 1:
    the loops const int ttj, local int x = 0 have a positive data reuse ratio: a factor 7.2
INFO at |project://mcl/input/programs/convolution-cc_1_0.mcl|(2682,4,<61,32>,<61,36>): instruction data[mti,mtj] has 0 bank conflicts
INFO at |project://mcl/input/programs/convolution-cc_1_0.mcl|(3403,1,<76,54>,<76,55>): instruction f[y,x] has 0 bank conflicts
INFO at |project://mcl/input/programs/convolution-cc_1_0.mcl|(1228,4,<34,40>,<34,44>): Multiple elements of data are loaded into shared memory, but there is only one store/load phase. It may be benificial to store/load in multiple phases.
INFO at |project://mcl/input/programs/convolution-cc_1_0.mcl|(3412,4,<76,63>,<76,67>): instruction data[ti * tyleHeight + y + k,tj + x] has 0 bank conflicts
INFO at |project://mcl/input/programs/convolution-cc_1_0.mcl|(2308,2,<53,28>,<53,30>): instruction f2[k] has 0 bank conflicts
INFO at |project://mcl/input/programs/convolution-cc_1_0.mcl|(3403,1,<76,54>,<76,55>): f[y,x] is accessed inside for-loop with index k but does not depend on it.
*/