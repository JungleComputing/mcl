/*
 * Copyright 2014 Pieter Hijma
 *
 * This file is part of MCL.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */



module convolution


import gpu;
import nvidia;
import cc_2_0;





cc_2_0 void convolve(const int outputHeight = 4096, const int outputWidth = 
        4096, const int filterHeight = 9, const int filterWidth = 9, 
        float[outputHeight,outputWidth] output, const float[outputHeight + 
        filterHeight / 2 * 2,outputWidth + filterWidth / 2 * 2] input, const 
        float[filterHeight,filterWidth] filter) {
    const int tyleHeight = 4;
    const int tyleWidth = 2;
    const int nrThreadsX = 32;
    const int nrThreadsY = 16;
    const int nrBlocksOutputHeight = outputHeight / (nrThreadsY * tyleHeight);
    const int nrBlocksOutputWidth = outputWidth / (nrThreadsX * tyleWidth);
    const int filterSize = filterWidth * filterHeight;
    const int fh = filterHeight / 2 * 2;
    const int fw = filterWidth / 2 * 2;
    const int ti_end = fh + nrThreadsY * tyleHeight;
    const int tj_end = fw + nrThreadsX * tyleWidth;
    foreach (const int bi in nrBlocksOutputHeight blocks) {
        foreach (const int bj in nrBlocksOutputWidth blocks) {
            shared float[filterHeight,filterWidth] f;
            f as float[filterSize] f2;
            filter as float[filterSize] filter2;
            shared float[ti_end,tj_end] data;
            const int nrThreadsNrThreadsX = 
                    cc_2_0.hierarchy.blocks.block.warps.warp.threads.nr_units;
            const int nrWarpsNrThreadsX = nrThreadsX / (1 * 
                    nrThreadsNrThreadsX);
            foreach (const int ti in nrThreadsY warps) {
                foreach (const int wtj in nrWarpsNrThreadsX warps) {
                    foreach (const int ttj in nrThreadsNrThreadsX threads) {
                        const int tj = wtj * (1 * nrThreadsNrThreadsX) + ttj;
                        const int yDataOffset = bi * (nrThreadsY * tyleHeight);
                        const int xDataOffset = bj * (nrThreadsX * tyleWidth);
                        const int j = xDataOffset + tj * tyleWidth;
                        const int i = yDataOffset + ti * tyleHeight;
                        local float[tyleHeight,tyleWidth] sum;
                        for (local int k = ti * nrThreadsX + tj; k < 
                                filterSize; k += nrThreadsX * nrThreadsY) {
                            f2[k] = filter2[k];
                        }
                        for (local int mti = ti; mti < ti_end; mti += 
                                nrThreadsY) {
                            for (local int mtj = tj; mtj < tj_end; mtj += 
                                    nrThreadsX) {
                                data[mti,mtj] = input[yDataOffset + mti,
                                        xDataOffset + mtj];
                            }
                        }
                        barrier(shared);
                        for (local int k = 0; k < tyleHeight; k++) {
                            for (local int l = 0; l < tyleWidth; l++) {
                                sum[k,l] = 0;
                            }
                        }
                        for (local int y = 0; y < filterHeight; y++) {
                            for (local int x = 0; x < filterWidth; x++) {
                                for (local int k = 0; k < tyleHeight; k++) {
                                    for (local int l = 0; l < tyleWidth; l++) {
                                        sum[k,l] = sum[k,l] + f[y,x] * data[ti 
                                                * tyleHeight + y + k,tj * 
                                                tyleWidth + x + l];
                                    }
                                }
                            }
                        }
                        for (local int k = 0; k < tyleHeight; k++) {
                            for (local int l = 0; l < tyleWidth; l++) {
                                output[i + k,j + l] = sum[k,l] / filterSize;
                            }
                        }
                    }
                }
            }
        }
    }
}



/*

INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(3897,3,<78,54>,<78,57>): Var sum[k,l]:
  in loop l:
    may benefit from cache l1_cache:
      best case: 1 / 16 cache line fetches
      worst case: 2 cache line fetches
INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(2979,3,<62,32>,<62,35>): Var sum[k,l]:
  in loop l:
    may benefit from cache l1_cache:
      best case: 1 / 16 cache line fetches
      worst case: 2 cache line fetches

INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(3413,1,<69,62>,<69,63>): instruction f[y,x] has 0 bank conflicts
INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(3422,4,<69,71>,<69,75>): instruction data[ti * tyleHeight + y + k,tj * tyleWidth + x + l] has 0 bank conflicts


INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(3875,6,<78,32>,<78,38>): Var output[i + k,j + l]:
  in loop l:
    may benefit from cache l2_cache:
      best case: 1 / 16 cache line fetches
      worst case: 2 cache line fetches
  in foreach loop ttj:
    does benefit from cache l2_cache:
      2 cache line fetches
INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(3391,3,<69,40>,<69,43>): Var sum[k,l]:
  in loop l:
    may benefit from cache l2_cache:
      best case: 1 / 16 cache line fetches
      worst case: 2 cache line fetches
      
INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(80,8,<12,12>,<12,20>): Memory on_chip is shared by more than one block, carefully consider the usage of memory spaces {"shared"}
INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(80,8,<12,12>,<12,20>): Memory regs is shared by more than one warp, carefully consider the usage of memory spaces {}

INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(2624,5,<55,48>,<55,53>): Memory access pattern of input[yDataOffset + mti,xDataOffset + mtj] is optimal
INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(2296,7,<49,36>,<49,43>): Memory access pattern of filter2[k] is optimal


INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(2624,5,<55,48>,<55,53>): Var input[yDataOffset + mti,xDataOffset + mtj]:
  in loop mtj:
    does not benefit from cache l1_cache:
      73 / 32 cache line fetches
 (may not be approximate: depends on loop at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(1566,3,<39,35>,<39,38>), depends on loop at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(1639,3,<40,39>,<40,42>))
  in foreach loop ttj:
    does benefit from cache l1_cache:
      1 cache line fetches
INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(3402,3,<69,51>,<69,54>): Var sum[k,l]:
  in loop l:
    may benefit from cache l1_cache:
      best case: 1 / 16 cache line fetches
      worst case: 2 cache line fetches
INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(2624,5,<55,48>,<55,53>): Var input[yDataOffset + mti,xDataOffset + mtj]:
  in loop mtj:
    does not benefit from cache l2_cache:
      73 / 32 cache line fetches
 (may not be approximate: depends on loop at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(1566,3,<39,35>,<39,38>), depends on loop at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(1639,3,<40,39>,<40,42>))
  in foreach loop ttj:
    does benefit from cache l2_cache:
      1 cache line fetches
INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(2296,7,<49,36>,<49,43>): Var filter2[k]:
  in loop k:
    may benefit from cache l2_cache:
      best case: 1296 / 512 cache line fetches
      worst case: 81 / 512 cache line fetches
 (may not be approximate: depends on loop at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(1505,2,<38,31>,<38,33>), depends on loop at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(1566,3,<39,35>,<39,38>), depends on loop at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(1639,3,<40,39>,<40,42>))
  in foreach loop ttj:
    does benefit from cache l2_cache:
      1 cache line fetches
INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(2288,2,<49,28>,<49,30>): instruction f2[k] has 0 bank conflicts

INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(3897,3,<78,54>,<78,57>): Var sum[k,l]:
  in loop l:
    may benefit from cache l2_cache:
      best case: 1 / 16 cache line fetches
      worst case: 2 cache line fetches
INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(2979,3,<62,32>,<62,35>): Var sum[k,l]:
  in loop l:
    may benefit from cache l2_cache:
      best case: 1 / 16 cache line fetches
      worst case: 2 cache line fetches
INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(3875,6,<78,32>,<78,38>): Var output[i + k,j + l]:
  in loop l:
    may benefit from cache l1_cache:
      best case: 1 / 16 cache line fetches
      worst case: 2 cache line fetches
  in foreach loop ttj:
    does benefit from cache l1_cache:
      2 cache line fetches
INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(2296,7,<49,36>,<49,43>): Var filter2[k]:
  in loop k:
    may benefit from cache l1_cache:
      best case: 81 / 32 cache line fetches
      worst case: 81 / 512 cache line fetches
 (may not be approximate: depends on loop at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(1505,2,<38,31>,<38,33>), depends on loop at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(1566,3,<39,35>,<39,38>), depends on loop at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(1639,3,<40,39>,<40,42>))
  in foreach loop ttj:
    does benefit from cache l1_cache:
      1 cache line fetches
INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(3391,3,<69,40>,<69,43>): Var sum[k,l]:
  in loop l:
    may benefit from cache l1_cache:
      best case: 1 / 16 cache line fetches
      worst case: 2 cache line fetches
INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(2608,4,<55,32>,<55,36>): instruction data[mti,mtj] has 0 bank conflicts


INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(3402,3,<69,51>,<69,54>): Var sum[k,l]:
  in loop l:
    may benefit from cache l2_cache:
      best case: 1 / 16 cache line fetches
      worst case: 2 cache line fetches
INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(3875,6,<78,32>,<78,38>): Memory access pattern of output[i + k,j + l] is not optimal


deze doet mij besluiten om naar 64 threads te gaan. 

INFO at |project://mcl/input/programs/convolution-cc_2_0-a.mcl|(3413,1,<69,62>,<69,63>): f[y,x] is accessed inside for-loop with index l but does not depend on it.





*/
