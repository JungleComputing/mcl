/*
 * Copyright 2014 Pieter Hijma
 *
 * This file is part of MCL.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */



module convolution


import gpu;





gpu void convolve(const int outputHeight, const int outputWidth, const int 
        filterHeight, const int filterWidth, float[outputHeight,outputWidth] 
        output, const float[outputHeight + filterHeight / 2 * 2,outputWidth + 
        filterWidth / 2 * 2] input, const float[filterHeight,filterWidth] 
        filter) {

    const int nrThreadsOutputWidth = 
            gpu.hierarchy.blocks.block.threads.max_nr_units;
    const int nrBlocksOutputWidth = outputWidth / nrThreadsOutputWidth;
    const int filterSize = filterWidth * filterHeight;
    const int filterLoop = filterSize / nrThreadsOutputWidth;
    foreach (const int i in outputHeight blocks) {
    
        foreach (const int bj in nrBlocksOutputWidth blocks) {
        
        	local float [filterHeight, filterWidth] f;
        	f as float[filterSize] f2;
        	filter as float[filterSize] filter2;
 
            foreach (const int tj in nrThreadsOutputWidth threads) {
            
                const int j = bj * nrThreadsOutputWidth + tj;
                float sum = 0.0;
             	int loopCount = filterLoop;
            	int findex = tj; 	    
            
            	if (tj < filterSize) {
            		loopCount = loopCount + 1;
            	}

            	for (int k = 0; k < loopCount; k++) {
            		f2[findex] = filter2[findex];
            		findex = findex + nrThreadsOutputWidth;
            	}
            	
            	barrier(local);
        
                for (int y = 0; y < filterHeight; y++) {
                
                    for (int x = 0; x < filterWidth; x++) {
                    
                        sum = sum + f[y, x] * input[i + y,j + x];
                    }
                }
                output[i,j] = sum;
            }
        }
    }
}
