/*
 * Copyright 2014 Pieter Hijma
 *
 * This file is part of MCL.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

module kmeans




import perfect;
import mic;
import xeon_phi;










xeon_phi void kmeans_kernel(const int npoints, const int nclusters, const int 
        nfeatures, const dev float[nfeatures,npoints] points, const dev 
        float[nclusters,nfeatures] clusters, dev int[npoints] pointsCluster) {
    const int nrVectorsNpoints = mic.hierarchy.threads.thread.vectors.nr_units;
    const int nrThreads = 16 * 4 * 59 * 8;
    const int nrElementsPerThread = (npoints + nrThreads - 1) / nrThreads;
    const int nrThreadsNpoints = (nrThreads + nrVectorsNpoints - 1) / (1 * 
            nrVectorsNpoints);
    foreach (const int tpid in nrThreadsNpoints threads) {
        foreach (const int vpid in nrVectorsNpoints vectors) {
            for (reg int elNo = 0; elNo < nrElementsPerThread; elNo++) {
                const int pid = (tpid * nrElementsPerThread + elNo) * 
                        nrVectorsNpoints + vpid;
                if (pid < npoints) {
                    reg int ind = 0;
                    reg float[nfeatures] point;
                    for (reg int feature = 0; feature < nfeatures; feature++) {
                        point[feature] = points[feature,pid];
                    }
                    reg float min_dist = 3.0E+38;
                    for (reg int cluster = 0; cluster < nclusters; cluster++) {
                        reg float dist = 0;
                        for (reg int feature = 0; feature < nfeatures; 
                                feature++) {
                            const float d = point[feature] - clusters[cluster,
                                    feature];
                            dist += d * d;
                        }
                        if (dist < min_dist) {
                            min_dist = dist;
                            ind = cluster;
                        }
                    }
                    pointsCluster[pid] = ind;
                }
            }
        }
    }
}

/*
getFeedback() crashes, like with kmeans-mic-v1.
*/
