/*
 * Copyright 2014 Pieter Hijma
 *
 * This file is part of MCL.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */



module convolution

import gpu;


gpu void convolve(const int outputHeight, const int outputWidth, const int 
        filterHeight, const int filterWidth, float[outputHeight,outputWidth] 
        output, const float[outputHeight + filterHeight / 2 * 2,outputWidth + 
        filterWidth / 2 * 2] input, const float[filterHeight,filterWidth] 
        filter) {

	const int tyleHeight = 2;
	const int tyleWidth = 2;
	const int nrThreadsX = 32;
	const int nrThreadsY = 32;
	const int nrBlocksOutputHeight = outputHeight / (nrThreadsY * tyleHeight);
    const int nrBlocksOutputWidth = outputWidth / (nrThreadsX * tyleWidth);
    const int filterSize = filterWidth * filterHeight;
    const int fh = filterHeight / 2 * 2;
    const int fw = filterWidth / 2 * 2;
    const int ti_end = fh + nrThreadsY * tyleHeight;
	const int tj_end = fw + nrThreadsX * tyleWidth;
     
    foreach (const int bi in nrBlocksOutputHeight blocks) {   
        foreach (const int bj in nrBlocksOutputWidth blocks) {
        
        	local float [filterHeight, filterWidth] f;
        	f as float[filterSize] f2;
        	filter as float[filterSize] filter2;
        	local float [ti_end, tj_end] data;
        	
        	foreach(const int ti in nrThreadsY threads) {
        		foreach(const int tj in nrThreadsX threads) {
         			const int yDataOffset = bi * (nrThreadsY * tyleHeight);
        			const int xDataOffset = bj * (nrThreadsX * tyleWidth); 
					const int j = xDataOffset + tj * tyleWidth;
					const int i = yDataOffset + ti * tyleHeight;
					float[tyleHeight, tyleWidth] sum;

	            	for (int k = ti * nrThreadsX + tj; k < filterSize; k += nrThreadsX * nrThreadsY) {
	            	 	f2[k] = filter2[k];
	            	}
	            	for (int mti = ti; mti < ti_end; mti += nrThreadsY) {
	            		for (int mtj = tj; mtj < tj_end; mtj += nrThreadsX) {
	            			data[mti, mtj] = input[yDataOffset + mti, xDataOffset + mtj];
	            		}
	            	}
            	
	            	barrier(local);
	        	    for (int k = 0; k < tyleHeight; k++) { 
	        	    	for (int l = 0; l < tyleWidth; l++) {
	                    	sum[k, l] = 0;
	                    }
	                }
	                for (int y = 0; y < filterHeight; y++) {	                
	                    for (int x = 0; x < filterWidth; x++) {
	                    	for (int k = 0; k < tyleHeight; k++) { 
	                    		for (int l = 0; l < tyleWidth; l++) {
	                    			sum[k, l] = sum[k, l] + f[y, x] * data[ti*tyleHeight + y + k,tj*tyleWidth + x + l];         
	                    		}
							}
	                    }
	                }
	                for (int k = 0; k < tyleHeight; k++) {
	                	for (int l = 0; l < tyleWidth; l++) {
		        			output[i+k,j+l] = sum[k, l] / filterSize;
		        		}
	        		}
	            }
	        }
        }
    }
}



/*

feedback to do multiple elements is not there anymore 


convolveKernel           : avg = 12.8 ms, total = 64.1 ms, count =         5

#GFLOPS: 214.52 GFLOPS
Effective Bandwidth: 11.309 GB/s
Bandwidth: 9.7671 GB/s



*/
