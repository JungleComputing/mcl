/*
 * Copyright 2014 Pieter Hijma
 *
 * This file is part of MCL.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */



module convolution


import perfect;
import mic;
import xeon_phi;





xeon_phi void convolve(const int outputHeight, const int outputWidth, const int 
        filterHeight, const int filterWidth, float[outputHeight,outputWidth] 
        output, const float[outputHeight + filterHeight -1,outputWidth + 
        filterWidth -1] input, const float[filterHeight,filterWidth] 
        filter) {
        
    const int nrVectorsW = mic.hierarchy.threads.thread.vectors.nr_units;
    const int nrElsW = 4;
    const int nrThreadsW = outputWidth / (nrElsW * nrVectorsW);
    
    const int nrElsH = 4;
    const int nrThreadsH = outputHeight / nrElsH;
    
    foreach (const int ti in nrThreadsH threads) {
        foreach (const int tj in nrThreadsW threads) {
            foreach (const int vj in nrVectorsW vectors) {
            
                float[filterHeight,filterWidth] filter2;
                float[nrElsH, nrElsW] output2;
                float[nrElsH + filterHeight - 1, nrElsW + filterWidth - 1] input2;
                
               
                for (int ei = 0; ei < nrElsH + filterHeight - 1; ei++) {
                    const int i = ti * nrElsH + ei;
                    for (int ej = 0; ej < nrElsW + filterWidth - 1; ej++) {
                        const int j = tj * (nrVectorsW * nrElsW) + vj * 
                                nrElsW + ej;
                        
                        input2[ei, ej] = input[i, j];
                    }
                }
                
                
                for (int y = 0; y < filterHeight; y++) {
                    for (int x = 0; x < filterWidth; x++) {
                        filter2[y,x] = filter[y,x];
                    }
                }
                
                
                for (int ei = 0; ei < nrElsH; ei++) {
                    const int i = ti * nrElsH + ei;
                    for (int ej = 0; ej < nrElsW; ej++) {
                        const int j = tj * (nrVectorsW * nrElsW) + vj * 
                                nrElsW + ej;
                        float sum = 0.0;
                        for (int y = 0; y < filterHeight; y++) {
                            for (int x = 0; x < filterWidth; x++) {
                                //sum = sum + filter2[y,x] * input[i + y,j + x];
                                sum = sum + filter2[y,x] * input2[ei + y,ej + x];
                            }
                        }
                        output2[ei,ej] = sum / (filterHeight * filterWidth);
                        //output[i,j] = sum / (filterHeight * filterWidth);
                    }
                }
                
                for (int ei = 0; ei < nrElsH; ei++) {
                    const int i = ti * nrElsH + ei;
                	for (int ej = 0; ej < nrElsW; ej++) {
                        const int j = tj * (nrVectorsW * nrElsW) + vj * 
                                nrElsW + ej;
                    	output[i, j] = output2[ei, ej];
                	}
                }
            }
        }
    }
}



/*

transformed the tiling in the j direction 
	from
		tj ej vj  
	to
		tj vj ej  (does not seem like a good idea)
	


INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(85,8,<12,14>,<12,22>): This is a cache-oriented architecture. Make sure that each access benefits from the cache(s)

INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(1679,6,<47,39>,<47,45>): Data reuse: filter[y,x] is accessed for nrThreadsH threads ti.
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(1436,5,<40,41>,<40,46>): Data reuse: For input[i,j]:
  For dimension 0:
    the loops const int tj, int ej = 0 may have a positive data reuse ratio: (filterWidth * outputWidth + 15 * outputWidth) / 256
    the loops const int tj, const int vj may have a positive data reuse ratio: outputWidth / 16
    the loops const int ti, int ei = 0 may have a positive data reuse ratio: (filterHeight * outputHeight + 15 * outputHeight) / (filterHeight + outputHeight - 1) / 16
    the loops int ei = 0, int ej = 0 may have a positive data reuse ratio: (filterHeight * filterWidth + (15 * filterHeight + (15 * filterWidth + 225))) / (filterHeight + 15)
    the loops const int ti, int ej = 0 may have a positive data reuse ratio: (filterWidth * outputHeight + 15 * outputHeight) / (outputHeight - 15) / 16
    the loops const int ti, const int vj may have a positive data reuse ratio: outputHeight / (outputHeight - 15)
    the loops const int ti, const int tj may have a positive data reuse ratio: outputHeight * outputWidth / (outputHeight - 15) / 4096
    the loops const int vj, int ei = 0 may have a positive data reuse ratio: (16 * filterHeight + 240) / (filterHeight + 15)
    the loops const int tj, int ei = 0 may have a positive data reuse ratio: (filterHeight * outputWidth + 15 * outputWidth) / (filterHeight + 15) / 256
  For dimension 1:
    the loops const int vj, int ej = 0 may have a positive data reuse ratio: (16 * filterWidth + 240) / (filterWidth + 255)
    the loops const int tj, int ej = 0 may have a positive data reuse ratio: (filterWidth * outputWidth + 15 * outputWidth) / (filterWidth + outputWidth - 241) / 256
    the loops const int tj, const int vj may have a positive data reuse ratio: outputWidth / (outputWidth - 15) / 16
    the loops const int ti, int ei = 0 may have a positive data reuse ratio: (filterHeight * outputHeight + 15 * outputHeight) / 16
    the loops int ei = 0, int ej = 0 may have a positive data reuse ratio: (filterHeight * filterWidth + (15 * filterHeight + (15 * filterWidth + 225))) / (filterWidth + 15)
    the loops const int ti, int ej = 0 may have a positive data reuse ratio: (filterWidth * outputHeight + 15 * outputHeight) / (filterWidth + 15) / 16
    the loops const int ti, const int vj may have a positive data reuse ratio: outputHeight / 241
    the loops const int ti, const int tj may have a positive data reuse ratio: outputHeight * outputWidth / (outputWidth - 255) / 4096
    the loops const int vj, int ei = 0 may have a positive data reuse ratio: (16 * filterHeight + 240) / 241
    the loops const int tj, int ei = 0 may have a positive data reuse ratio: (filterHeight * outputWidth + 15 * outputWidth) / (outputWidth - 255) / 256
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(2347,7,<61,44>,<61,51>): Data reuse: filter2[y,x] is accessed inside for-loop with index ei but does not depend on it.
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(2347,7,<61,44>,<61,51>): Data reuse: filter2[y,x] is accessed inside for-loop with index ej but does not depend on it.
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(1679,6,<47,39>,<47,45>): Data reuse: filter[y,x] is accessed for nrVectorsW vectors vj.
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(2362,6,<61,59>,<61,65>): Data reuse: For input2[ei + y,ej + x]:
  For dimension 0:
    the loops int ei = 0, int y = 0 may have a positive data reuse ratio: 16 * filterHeight / (filterHeight + 15)
    the loops int ej = 0, int y = 0  have a positive data reuse ratio: 16
    the loops int ei = 0, int ej = 0  have a positive data reuse ratio: 16
  For dimension 1:
    the loops int ei = 0, int x = 0  have a positive data reuse ratio: 16
    the loops int ej = 0, int x = 0 may have a positive data reuse ratio: 16 * filterWidth / (filterWidth + 15)
    the loops int ei = 0, int ej = 0  have a positive data reuse ratio: 16
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(1679,6,<47,39>,<47,45>): Data reuse: filter[y,x] is accessed for nrThreadsW threads tj.



INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(2374,6,<61,59>,<61,65>): Var input2[ei + y,ej + x]:
  in loop x:
    may benefit from cache l1_cache:
      best case: filterWidth / 16 cache line fetches
      worst case: filterWidth cache line fetches
  in foreach loop vj:
    does benefit from cache l1_cache:
      1 cache line fetches
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(2374,6,<61,59>,<61,65>): Var input2[ei + y,ej + x]:
  in loop x:
    may benefit from cache l2_cache:
      best case: filterWidth / 16 cache line fetches
      worst case: filterWidth cache line fetches
  in foreach loop vj:
    does benefit from cache l2_cache:
      1 cache line fetches
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(1448,5,<40,41>,<40,46>): Var input[i,j]:
  in loop ej:
    may benefit from cache l2_cache:
      best case: (filterWidth + 15) / 16 cache line fetches
      worst case: filterWidth + 15 cache line fetches
  in foreach loop vj:
    does not benefit from cache l2_cache:
      16 cache line fetches
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(1022,6,<31,79>,<31,85>): for declaration input2 with size -4 * filterHeight + (4 * (filterHeight * filterWidth) + (4 * (filterHeight * nrElsW) + (-4 * filterWidth + (4 * (filterWidth * nrElsH) + (-4 * nrElsH + (4 * (nrElsH * nrElsW) + -4 * nrElsW)))))) + 4 bytes, if possible, try to adjust the size in relation to:
  for cache l1_cache:
    the capacity: 32 kB
    the cache line size: 64 B
  for cache l2_cache:
    the capacity: 512 kB
    the cache line size: 64 B
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(883,7,<29,52>,<29,59>): for declaration filter2 with size 4 * (filterHeight * filterWidth) bytes, if possible, try to adjust the size in relation to:
  for cache l1_cache:
    the capacity: 32 kB
    the cache line size: 64 B
  for cache l2_cache:
    the capacity: 512 kB
    the cache line size: 64 B
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(1431,6,<40,24>,<40,30>): Var input2[ei,ej]:
  in loop ej:
    may benefit from cache l1_cache:
      best case: (filterWidth + 15) / 16 cache line fetches
      worst case: filterWidth + 15 cache line fetches
  in foreach loop vj:
    does benefit from cache l1_cache:
      1 cache line fetches
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(1691,6,<47,39>,<47,45>): Var filter[y,x]:
  in loop x:
    may benefit from cache l1_cache:
      best case: filterWidth / 16 cache line fetches
      worst case: filterWidth cache line fetches
  in foreach loop vj:
    does benefit from cache l1_cache:
      1 cache line fetches
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(1431,6,<40,24>,<40,30>): Var input2[ei,ej]:
  in loop ej:
    may benefit from cache l2_cache:
      best case: (filterWidth + 15) / 16 cache line fetches
      worst case: filterWidth + 15 cache line fetches
  in foreach loop vj:
    does benefit from cache l2_cache:
      1 cache line fetches
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(1691,6,<47,39>,<47,45>): Var filter[y,x]:
  in loop x:
    may benefit from cache l2_cache:
      best case: filterWidth / 16 cache line fetches
      worst case: filterWidth cache line fetches
  in foreach loop vj:
    does benefit from cache l2_cache:
      1 cache line fetches
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(2477,7,<64,24>,<64,31>): Var output2[ei,ej]:
  in loop ej:
    may benefit from cache l2_cache:
      best case: 1 cache line fetches
      worst case: 16 cache line fetches
  in foreach loop vj:
    does benefit from cache l2_cache:
      1 cache line fetches
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(85,8,<12,14>,<12,22>): This is a cache-oriented architecture. Make sure that each access benefits from the cache(s)
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(2477,7,<64,24>,<64,31>): Var output2[ei,ej]:
  in loop ej:
    may benefit from cache l1_cache:
      best case: 1 cache line fetches
      worst case: 16 cache line fetches
  in foreach loop vj:
    does benefit from cache l1_cache:
      1 cache line fetches
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(1676,7,<47,24>,<47,31>): Var filter2[y,x]:
  in loop x:
    may benefit from cache l1_cache:
      best case: filterWidth / 16 cache line fetches
      worst case: filterWidth cache line fetches
  in foreach loop vj:
    does benefit from cache l1_cache:
      1 cache line fetches
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(934,7,<30,42>,<30,49>): for declaration output2 with size 4 * (nrElsH * nrElsW) bytes, if possible, try to adjust the size in relation to:
  for cache l1_cache:
    the capacity: 32 kB
    the cache line size: 64 B
  for cache l2_cache:
    the capacity: 512 kB
    the cache line size: 64 B
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(1676,7,<47,24>,<47,31>): Var filter2[y,x]:
  in loop x:
    may benefit from cache l2_cache:
      best case: filterWidth / 16 cache line fetches
      worst case: filterWidth cache line fetches
  in foreach loop vj:
    does benefit from cache l2_cache:
      1 cache line fetches
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(2902,7,<73,36>,<73,43>): Var output2[ei,ej]:
  in loop ej:
    may benefit from cache l2_cache:
      best case: 1 cache line fetches
      worst case: 16 cache line fetches
  in foreach loop vj:
    does benefit from cache l2_cache:
      1 cache line fetches
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(2359,7,<61,44>,<61,51>): Var filter2[y,x]:
  in loop x:
    may benefit from cache l1_cache:
      best case: filterWidth / 16 cache line fetches
      worst case: filterWidth cache line fetches
  in foreach loop vj:
    does benefit from cache l1_cache:
      1 cache line fetches
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(2887,6,<73,21>,<73,27>): Var output[i,j]:
  in loop ej:
    may benefit from cache l1_cache:
      best case: 1 cache line fetches
      worst case: 16 cache line fetches
  in foreach loop vj:
    does not benefit from cache l1_cache:
      16 cache line fetches
WARNING at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(1862,1,<53,30>,<53,31>): The variable i is unused
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(2359,7,<61,44>,<61,51>): Var filter2[y,x]:
  in loop x:
    may benefit from cache l2_cache:
      best case: filterWidth / 16 cache line fetches
      worst case: filterWidth cache line fetches
  in foreach loop vj:
    does benefit from cache l2_cache:
      1 cache line fetches
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(2902,7,<73,36>,<73,43>): Var output2[ei,ej]:
  in loop ej:
    may benefit from cache l1_cache:
      best case: 1 cache line fetches
      worst case: 16 cache line fetches
  in foreach loop vj:
    does benefit from cache l1_cache:
      1 cache line fetches
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(2887,6,<73,21>,<73,27>): Var output[i,j]:
  in loop ej:
    may benefit from cache l2_cache:
      best case: 1 cache line fetches
      worst case: 16 cache line fetches
  in foreach loop vj:
    does not benefit from cache l2_cache:
      16 cache line fetches
INFO at |project://mcl/input/programs/convolution-xeon_phi-v2.mcl|(1448,5,<40,41>,<40,46>): Var input[i,j]:
  in loop ej:
    may benefit from cache l1_cache:
      best case: (filterWidth + 15) / 16 cache line fetches
      worst case: filterWidth + 15 cache line fetches
  in foreach loop vj:
    does not benefit from cache l1_cache:
      16 cache line fetches




convolveKernel           : avg = 21.4 ms, total =  107 ms, count =         5

#GFLOPS: 128.42 GFLOPS
Effective Bandwidth: 496.29 GB/s
Bandwidth: 5.8456 GB/s




*/
