/*
 * Copyright 2014 Pieter Hijma
 *
 * This file is part of MCL.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

module raytracer

import perfect;
import math;

type Vec {
	float x;
	float y;
	float z;
}

type Ray {
	Vec origin;
	Vec direction;
}

type Sphere {
	float radius;
	Vec position;
	Vec emission;
	Vec color;
	float reflectionType;
}


type Camera {
	Vec orig;
	Vec target;
	Vec direction;
	Vec x;
	Vec y;
}

const float EPSILON = 0.01;
const float FLOAT_PI = 3.14159265358979323846;

const float DIFF = 0.0;
const float SPEC = 1.0;
//const float REFR = 2.0;



perfect void vinit2m(main Vec v, float a, float b, float c) {
	v.x = a; 
	v.y = b;
	v.z = c;
}

perfect void vassign2m(main Vec v, Vec a) {
	vinit2m(v, a.x, a.y, a.z);
}

perfect void vinit(Vec v, float a, float b, float c) {
	v.x = a; 
	v.y = b;
	v.z = c;
}

perfect void vassignfm(Vec v, main Vec a) {
	vinit(v, a.x, a.y, a.z);
}

perfect void vassign(Vec v, Vec a) {
	vinit(v, a.x, a.y, a.z);
}

perfect void vclr(Vec a) {
	vinit(a, 0.0, 0.0, 0.0);
}


perfect void vadd(Vec v, Vec a, Vec b) {
	vinit(v, a.x + b.x, a.y + b.y, a.z + b.z);
}
perfect void vsub(Vec v, Vec a, Vec b) {
	vinit(v, a.x - b.x, a.y - b.y, a.z - b.z);
}
perfect void vmul(Vec v, Vec a, Vec b) {
	vinit(v, a.x * b.x, a.y * b.y, a.z * b.z);
}
/*
perfect void vsadd(Vec v, float a, Vec b) {
	vinit(v, b.x + a, b.y + a, b.z + a);
}
perfect void vssub(Vec v, float a, Vec b) {
	vinit(v, b.x - a, b.y - a, b.z - a);
}
*/
perfect void vsmul(Vec v, float a, Vec b) {
	vinit(v, b.x * a, b.y * a, b.z * a);
}
perfect float vdot(Vec a, Vec b) {
	return a.x * b.x + a.y * b.y + a.z * b.z;
}
perfect void vnorm(Vec v) {
	float l = 1.0 / sqrt(vdot(v, v));
	vsmul(v, l, v);
}
perfect void vxcross(Vec v, Vec a, Vec b) {
	vinit(v, a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}
perfect bool viszero(Vec v) {
	return ((v.x == 0.0) && (v.y == 0.0)) && (v.z == 0.0);
}


perfect void rinit(Ray r, Vec origin, Vec direction) {
	vassign(r.origin, origin);
	vassign(r.direction, direction);
}


perfect void rassign(Ray a, Ray b) {
	vassign(a.origin, b.origin);
	vassign(a.direction, b.direction);
}


perfect float getRandom(uint seed0, uint seed1) {
	seed0 = 36969 * ((seed0 & 65535) + (seed0 >> 16));
	seed1 = 18000 * ((seed1 & 65535) + (seed1 >> 16));
	
	int ires = (seed0 << 16) + seed1;
	
	//float fres = toFloat(ires & 0x007fffff) | 0x40000000;
	float fres = toFloat((ires & 8388607) | 1073741824);
	
	return (fres - 2.0) / 2.0;
}

// ok
perfect float sphereIntersect(main Sphere s, Ray r) {
	
	Vec op;
	Vec sPos;
	vassignfm(sPos, s.position);
	vsub(op, sPos, r.origin);
	
	float b = vdot(op, r.direction);
	float det = b * b - vdot(op, op) + s.radius * s.radius;
	if (det < 0.0) {
		return 0.0;
	}
	else {
		det = sqrt(det);
	}
	
	float t = b - det;
	if (t > EPSILON) {
		return t;
	}
	else {
		t = b + det;
		if (t > EPSILON) {
			return t;
		}
		else {
			return 0.0;
		}
	}
}


// ok
perfect bool intersect(int nrSpheres, main Sphere[nrSpheres] spheres, Ray r, float t,
		int id) {
	
	t = 1e20;
	float inf = t;
	
	for (int i = nrSpheres - 1; i >= 0; i--) {
		float d = sphereIntersect(spheres[i], r);
		if ((d != 0.0) && (d < t)) {
			t = d;
			id = i;
		}
	}
	
	return t < inf;
}


perfect bool intersectP(int nrSpheres, main Sphere[nrSpheres] spheres, Ray r, 
		float maxt) {
	for (int i = nrSpheres - 1; i >= 0; i--) {
		float d = sphereIntersect(spheres[i], r);
		if (d != 0.0 && d < maxt) {
			return true;
		}
	} 
	
	return false;
}


perfect void uniformSampleSphere(float u1, float u2, Vec v) {
	float zz = 1.0 - 2.0 * u1;
	float r = sqrt(max(0.0, 1.0 - zz * zz));
	float phi = 2.0 * FLOAT_PI * u2;
	float xx = r * cos(phi);
	float yy = r * sin(phi);
	
	vinit(v, xx, yy, zz);
}
	
	

// ok
perfect void sampleLights(int nrSpheres, main Sphere[nrSpheres] spheres, 
		uint seed0, uint seed1, Vec hitPoint, Vec normal, Vec result) {
		
	vclr(result);
	
	for (int i = 0; i < nrSpheres; i++) {
		//Sphere light = spheres[i];
		
		Vec sphereEmission;
		vassignfm(sphereEmission, spheres[i].emission);

		if (!viszero(sphereEmission)) {
			Ray shadowRay;
			vassign(shadowRay.origin, hitPoint);
			
			Vec unitSpherePoint;
			
			float u1 = getRandom(seed0, seed1);
			float u2 = getRandom(seed0, seed1);
			uniformSampleSphere(u1, u2, unitSpherePoint);
			
			Vec spherePoint;
			vsmul(spherePoint, spheres[i].radius, unitSpherePoint);
			Vec spherePosition;
			vassignfm(spherePosition, spheres[i].position);
			vadd(spherePoint, spherePoint, spherePosition);
			
			vsub(shadowRay.direction, spherePoint, hitPoint);
			float len = sqrt(vdot(shadowRay.direction, shadowRay.direction));
			vsmul(shadowRay.direction, 1.0 / len, shadowRay.direction);
			
			float wo = vdot(shadowRay.direction, unitSpherePoint);
			if (wo <= 0.0) {
				wo = -wo;
				float wi = vdot(shadowRay.direction, normal);
				if ((wi > 0.0) && !intersectP(nrSpheres, spheres, shadowRay, len - EPSILON)) {
					float s = (4.0 * FLOAT_PI * spheres[i].radius * spheres[i].radius) *
						wi * wo / (len * len);
						vsmul(sphereEmission, s, sphereEmission);
						vadd(result, result, sphereEmission);
				}
			}
		}
	}
}


// ok
perfect int radiancePathTracing(int nrSpheres, main Sphere[nrSpheres] spheres,
		Ray startRay, uint seed0, uint seed1, Vec result) {
	
	Ray currentRay;
	rassign(currentRay, startRay);
	
	Vec rad;
	vinit(rad, 0.0, 0.0, 0.0);
	Vec throughput;
	vinit(throughput, 1.0, 1.0, 1.0);
	
	bool specularBounce = true;
	
	for (int depth = 0; true; depth++) {
		if (depth > 6) {
			vassign(result, rad);
			return -1;
		}
		
		float t;
		int id = 0;
		if (!intersect(nrSpheres, spheres, currentRay, t, id)) {
			vassign(result, rad);
			return -1;
		}
		
		//Sphere obj = spheres[id]; // the hit object;
		
		Vec hitPoint;
		vsmul(hitPoint, t, currentRay.direction);
		vadd(hitPoint, currentRay.origin, hitPoint);
		
		Vec normal;
		Vec spherePosition;
		vassignfm(spherePosition, spheres[id].position);
		vsub(normal, hitPoint, spherePosition);
		vnorm(normal);
		
		const float dp = vdot(normal, currentRay.direction);
		
		Vec nl;
		float invSignDP = -1.0 * sign(dp);
		vsmul(nl, invSignDP, normal);
		
		Vec eCol;
		Vec sphereEmission;
		vassignfm(sphereEmission, spheres[id].emission);
		Vec sphereColor;
		vassignfm(sphereColor, spheres[id].color);

		vassign(eCol, sphereEmission);
		if (!viszero(eCol)) {
			if (specularBounce) {
				vsmul(eCol, fabs(dp), eCol);
				vmul(eCol, throughput, eCol);
				vadd(rad, rad, eCol);
			}
			vassign(result, rad);
			return -1;
		}
		
		
		if (spheres[id].reflectionType == DIFF) {
			specularBounce = false;
			vmul(throughput, throughput, sphereColor);
			
			// direct lighting component
			Vec ld;
			sampleLights(nrSpheres, spheres, seed0, seed1, hitPoint, nl, ld);
			vmul(ld, throughput, ld);
			vadd(rad, rad, ld);
			
			// diffuse component
			
			float r1 = 2.0 * FLOAT_PI * getRandom(seed0, seed1);
			float r2 = getRandom(seed0, seed1);
			float r2s = sqrt(r2);
			
			Vec w;
			vassign(w, nl);
			
			Vec u;
			Vec a;
			
			if (fabs(w.x) > 0.1) {
				vinit(a, 0.0, 1.0, 0.0);
			}
			else {
				vinit(a, 1.0, 0.0, 0.0);
			}
			vxcross(u, a, w);
			vnorm(u);
			
			Vec v;
			vxcross(v, w, u);
			
			Vec newDir;
			vsmul(u, cos(r1) * r2s, u);
			vsmul(v, sin(r1) * r2s, v);
			vadd(newDir, u, v);
			vsmul(w, sqrt(1 - r2), w);
			vadd(newDir, newDir, w);
			
			vassign(currentRay.origin, hitPoint);
			vassign(currentRay.direction, newDir);
		}
		else if (spheres[id].reflectionType == SPEC) {
			specularBounce = true;
			
			Vec newDir;
			vsmul(newDir, 2.0 * vdot(normal, currentRay.direction), normal);
			vsub(newDir, currentRay.direction, newDir);
			vmul(throughput, throughput, sphereColor);
			rinit(currentRay, hitPoint, newDir);
		}
		else {
			specularBounce = true;
			
			Vec newDir;
			vsmul(newDir, 2.0 * vdot(normal, currentRay.direction), normal);
			vsub(newDir, currentRay.direction, newDir);
			
			Ray reflRay;
			rinit(reflRay, hitPoint, newDir);
			
			// ideal dielectric refraction
			bool into = vdot(normal, nl) > 0;
			
			// ray from outside going in?
			
			float nc = 1.0;
			float nt = 1.5;
			float nnt = 0.0;
			if (into) {
				nnt = nc / nt;
			}
			else {
				nnt = nt / nc;
			}
			
			float ddn = vdot(currentRay.direction, nl);
			float cos2t = 1.0 - nnt * nnt * (1.0 - ddn * ddn);
			
			if (cos2t < 0.0) {
				vmul(throughput, throughput, sphereColor);
				rassign(currentRay, reflRay);
			}
			else {
				float kk = 0.0;
				if (into) {
					kk = 1.0;
				}
				else {
					kk = -1.0;
				}
				kk = kk * (ddn * nnt + sqrt(cos2t));

				Vec nkk;
				vsmul(nkk, kk, normal);
				Vec transDir;
				vsmul(transDir, nnt, currentRay.direction);
				vsub(transDir, transDir, nkk);
				vnorm(transDir);

				float a = nt - nc;
				float b = nt + nc;
				float r0 = a * a / (b * b);
				float c = 1.0; 
				if (into) {
					c = c - -ddn;
				}
				else {
					c = c - vdot(transDir, normal);
				}
				
				float re = r0 + (1.0 - r0) * c * c * c * c * c;
				float tr = 1.0 - re;
				float p = 0.25 + 0.5 * re;
				float rp = re / p;
				float tp = tr / (1.0 - p);
				
				if (getRandom(seed0, seed1) < p) {
					vsmul(throughput, rp, throughput);
					vmul(throughput, throughput, sphereColor);
					rassign(currentRay, reflRay);
				}
				else {
					vsmul(throughput, tp, throughput);
					vmul(throughput, throughput, sphereColor);
					
					rinit(currentRay, hitPoint, transDir);
				}
			}
		}
	}
}


// ok
perfect void generateCameraRay(main Camera camera, uint seed0, uint seed1, 
		int width, int height, int x, int y, Ray ray) {
	
	float invWidth = 1.0 / width;
	float invHeight = 1.0 / height;
	float r1 = getRandom(seed0, seed1) - 0.5;
	float r2 = getRandom(seed0, seed1) - 0.5;
	float kcx = (x + r1) * invWidth - 0.5;
	float kcy = (y + r2) * invHeight - 0.5;
	
	Vec rdir;
	vinit(rdir, camera.x.x * kcx + camera.y.x * kcy + camera.direction.x,
				camera.x.y * kcx + camera.y.y * kcy + camera.direction.y,
				camera.x.z * kcx + camera.y.z * kcy + camera.direction.z);
				
	Vec rorig;
	vsmul(rorig, 0.1, rdir);
	Vec corig;
	vassignfm(corig, camera.orig);
	vadd(rorig, rorig, corig);
	
	vnorm(rdir);
	rinit(ray, rorig, rdir);

}


// doesn't work when directly translated to cc_2_0, 
// needs less than 1024 threads (perhaps because of registers??)
perfect void radiance(int h, int w, Vec[h][w] colors, 
		int height, int width, uint[height][width][2] seeds, 
		int nrSpheres, Sphere[nrSpheres] spheres, Camera camera,
		int xOffset, int yOffset, int currentSample) {
	
	camera.target.x = 0.0; // to prevent a 'target unused' warning that messes
	                       // up generating code.
		
	foreach (int y in h threads) {
		foreach (int x in w threads) {
			int realY = y + yOffset;
			int realX = x + xOffset;
			
			//int id = realY * width + realX;
			//int id2 = 2 * id;
			
			if (y < h) {
			
				uint seed0 = seeds[realY][realX][0];
				uint seed1 = seeds[realY][realX][1];
			
				Ray ray;
				generateCameraRay(camera, seed0, seed1, width, height, 
					realX, realY, ray);
			
				Vec r;
				radiancePathTracing(nrSpheres, spheres, ray, seed0, seed1, r);
			
				if (currentSample == 0) {
					vassign2m(colors[y][x], r);
				}
				else {
					float k1 = currentSample;
					float k2 = 1.0 / (k1 + 1.0);
					colors[y][x].x = (colors[y][x].x * k1 + r.x) * k2;
					colors[y][x].y = (colors[y][x].y * k1 + r.y) * k2;
					colors[y][x].z = (colors[y][x].z * k1 + r.z) * k2;
				}
			
				seeds[realY][realX][0] = seed0;
				seeds[realY][realX][1] = seed1;
			}
		}
	}
}
