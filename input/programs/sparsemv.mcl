/*
 * Copyright 2014 Pieter Hijma
 *
 * This file is part of MCL.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */



module sparsemv

import perfect;

// Sparsemv: sparse matrix - vector multiplication.
// Representation: Compressed Sparse Row (CSR).

perfect void sparsemv(int n, int m, int nz, int[n+1] air, int[nz] ajc, float[nz] avalues, float[m] b, float[n] c) {
	foreach(int arow in n threads) {
		// Compute element c[arow] in this thread.
		c[arow] = 0;
        for (int i = air[arow]; i < air[arow + 1]; i++) {
            c[arow] = c[arow] + avalues[i] * b[ajc[i]];
        }
    }
}

/*
INFO at |project://mcl/input/programs/sparsemv.mcl|(148,8,<8,13>,<8,21>): computation:
  threads:
    loads: 
      main: 3*n*(air[arow+1]-air[arow]) (may not be accurate: depends on loop at |project://mcl/input/programs/sparsemv.mcl|(264,4,<9,13>,<9,17>))
    instructions: 
      2*n*(air[arow+1]-air[arow]) (may not be accurate: depends on loop at |project://mcl/input/programs/sparsemv.mcl|(264,4,<9,13>,<9,17>))
    stores: 
      main: n*(air[arow+1]-air[arow])+n (may not be accurate: depends on loop at |project://mcl/input/programs/sparsemv.mcl|(264,4,<9,13>,<9,17>))
INFO at |project://mcl/input/programs/sparsemv.mcl|(148,8,<8,13>,<8,21>): indexing:
  threads:
    loads: 
      main: n*(air[arow+1]-air[arow]) (may not be accurate: depends on loop at |project://mcl/input/programs/sparsemv.mcl|(264,4,<9,13>,<9,17>))
    instructions: 
      n*(air[arow+1]-air[arow]) (may not be accurate: depends on loop at |project://mcl/input/programs/sparsemv.mcl|(264,4,<9,13>,<9,17>))
    stores: 
      main: 0 (may not be accurate: depends on loop at |project://mcl/input/programs/sparsemv.mcl|(264,4,<9,13>,<9,17>))
INFO at |project://mcl/input/programs/sparsemv.mcl|(148,8,<8,13>,<8,21>): control flow:
  threads:
    loads: 
      main: n*(air[arow+1]-air[arow])+n (may not be accurate: depends on loop at |project://mcl/input/programs/sparsemv.mcl|(264,4,<9,13>,<9,17>))
    instructions: 
      2*n*(air[arow+1]-air[arow]) (may not be accurate: depends on loop at |project://mcl/input/programs/sparsemv.mcl|(264,4,<9,13>,<9,17>))
    stores: 
      main: 0 (may not be accurate: depends on loop at |project://mcl/input/programs/sparsemv.mcl|(264,4,<9,13>,<9,17>))
INFO at |project://mcl/input/programs/sparsemv.mcl|(148,8,<8,13>,<8,21>): Arithmetic intensity: 2*n*(air[arow+1]-air[arow])*(4*n*(air[arow+1]-air[arow])+n)^(-1)

This is somewhat useless, as it refers to the contents of the air array and the arow loop index.

openCL.run(NDRange(2048, 32), NDRange(32, 32)
pre                      : avg =   17 ms, total =   51 ms, count =         3

sparsemvKernel           : avg =   17 ms, total =   17 ms, count =         1

sparsemvKernel           : avg =   17 ms, total =   34 ms, count =         2

sparsemvKernel           : avg =   17 ms, total = 51.1 ms, count =         3

sparsemvKernel           : avg =   17 ms, total = 68.1 ms, count =         4

sparsemvKernel           : avg =   17 ms, total =   85 ms, count =         5

Bandwidth: 3.82 GB/s

*/
