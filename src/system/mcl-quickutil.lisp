;;;; This file was automatically generated by Quickutil.
;;;; See http://quickutil.org for details.

;;;; To regenerate:
;;;; (qtlc:save-utils-as "system/mcl-quickutil.lisp" :utilities '(:MAP-TREE :IOTA :TRANSPOSE) :ensure-package T :package :MCL-QUICKUTIL)

(eval-when (:compile-toplevel :load-toplevel :execute)
  (unless (find-package :MCL-QUICKUTIL)
    (defpackage :MCL-QUICKUTIL
      (:documentation "Package that contains Quickutil utility functions.")
      (:use #:cl))))

(in-package :MCL-QUICKUTIL)

(when (boundp '*utilities*)
  (setf *utilities* (union *utilities* '(:MAP-TREE :IOTA :TRANSPOSE))))

  (defun map-tree (function tree)
    "Map `function` to each of the leave of `tree`."
    (check-type tree cons)
    (labels ((rec (tree)
               (cond
                 ((null tree) nil)
                 ((atom tree) (funcall function tree))
                 ((consp tree)
                  (cons (rec (car tree))
                        (rec (cdr tree)))))))
      (rec tree)))
  

  (declaim (inline iota))
  (defun iota (n &key (start 0) (step 1))
    "Return a list of `n` numbers, starting from `start` (with numeric contagion
from `step` applied), each consequtive number being the sum of the previous one
and `step`. `start` defaults to `0` and `step` to `1`.

Examples:

    (iota 4)                      => (0 1 2 3)
    (iota 3 :start 1 :step 1.0)   => (1.0 2.0 3.0)
    (iota 3 :start -1 :step -1/2) => (-1 -3/2 -2)"
    (declare (type (integer 0) n) (number start step))
    (loop repeat n
          ;; KLUDGE: get numeric contagion right for the first element too
          for i = (+ (- (+ start step) step)) then (+ i step)
          collect i))
  

  (defun transpose (lists)
    "Analog to matrix transpose for a list of lists given by `lists`."
    (apply #'mapcar #'list lists))
  
(eval-when (:compile-toplevel :load-toplevel :execute)
  (export '(map-tree iota transpose)))

;;;; END OF system/mcl-quickutil.lisp ;;;;
